SERVICE = "BassAndEffects"

require "playerbase"

density = 90
complexity = 90
range = 49
constantBass = false

#(ratio is array of ratios for transitioning 
# to states, density is a scale of [0, 100) to determine the amount of rest
# complexity is a scale of [0, 100) to 
# determine variation and complexity to rhythm)
def makeRatioRhythm(ratio):
    i = idiv(complexity, 20)
    if i == 0
        ratio[idiv(99 - density, 20)] = [0, 100]
    elif i == 1
        ratio[1] = [0, density]
        ratio[2] = [density, 100]
    elif i == 4
        ratio[4] = [0, 67]
        ratio[3] = [67, 100]
    else
        ratio[i] = [0, 46]
        ratio[i + 1] = [46, 73]
        ratio[i - 1] = [73, 100]

#(seq is the sequence of notes so far, ratio is array of ratios for transitioning
# to states, cur_scale, cur_chord, cur_bass, density is a scale of [0, 100) to 
# determine the amount of rest, complexity is a scale of [0, 100) to
# determine variation for eaxmple not starting on root, use of non-chord tones 
# and non-harmonic tones, wider jumps, range determines pitch range on a scale of [0, 100))
def makeRatioPitch(seq, ratio):
    i = idiv(complexity, 20)
    if seq == []:
        if i == 0:
            restRatio = 0
        elif i == 1:
            restRatio = 10
        else:
            restRatio = 99 - density
    else:
        if i == 0:
            restRatio = 99
        elif i == 1:
            restRatio = 99 - density
            if seq[0][0] == 12:
                restRatio = restRatio - 20
                if restRatio < 0:
                    restRatio = 0
            else:
                restRatio = restRatio + 20
                if restRatio > 99:
                    restRatio = 99
        else:
            restRatio = 99 - density
    ratio[12] = [0, restRatio + 1]
    numNotesInChord = 0
    for i = 0 to 12
        if cur_chord[i]
            numNotesInChord = numNotesInChord + 1
    ratioInterval = 33
    if numNotesInChord == 4
        ratioInterval = ratioInterval - 8
    ratioInterval = int(ratioInterval * ((100 - restRatio) / 100))
    nthNoteInChord = 0
    total = 0
    for i = 0 to 12
        if cur_chord[i]
            ratio[i][0] = ratio[i][0] + nthNoteInChord * ratioInterval + 1 + restRatio
            ratio[i][1] = ratio[i][0] + ratioInterval
            x = i
            if numNotesInChord == 3 and nthNoteInChord == 2
                ratio[i][1] = ratio[i][1] + 1
            total = total + ratioInterval
            nthNoteInChord = nthNoteInChord + 1
        else
            ratio[i] = [-1, 0]
    #add remaining ratios caused by decimal truncation to the last possible note
    #of the scale
    ratio[x][1] = ratio[x][1] + (100 - total)

#(seq is the seq of rhythms so far, ratio is array of ratios for 
# transitioning to states, beatsLeft is num of beats left in the measure)
def MarkovRhythm(seq, ratio, beatsLeft):
    if beatsLeft < 0.2
        return seq
    x = int(random() * 100)
    for i = 0 to len(ratio)
        if ratio[i][0] <= x and ratio[i][1] > x and
           beatsLeft - 4 / (2.0 ** real(i)) > -0.2
            seq.append(i)
            beatsLeft = beatsLeft - 4 / (2.0 ** real(i))
    MarkovRhythm(seq, ratio, beatsLeft)

#(seq is the seq of notes so far, ratio is array of ratios for 
# transitioning to states, rhythmSeq is array of rhythm seq to match the pitch)
def MarkovPitch(seq, ratio, rhythmSeq):
    if len(seq) == len(rhythmSeq)
        return seq
    x = int(random() * 100)
    for i = 0 to len(ratio)
        if ratio[i][0] <= x and ratio[i][1] > x
            seq.append([i, rhythmSeq[len(seq)]])
    makeRatioPitch(seq, ratio)
    MarkovPitch(seq, ratio, rhythmSeq)

def play_a_measure()
    # compute a measure using these variables:
    #    cur_style - a symbol representing style to play (if
    #       this is not your style, do not play)
    #    cur_start_beat - what beat to start on if you are stopped
    #    cur_stop_beat - what beat to stop on if you have started (you can
    #       stop slightly late; generally you should not start any notes 
    #       at or after tm_stop_beat but you can play a short note on 
    #       tm_stop_beat if it is stylistically sensible.)
    #    cur_beats_per_measure - the current time signature as an integer
    #    cur_bps - current beats per second (the vtsched will implement this
    #       but reading the vtsched timemap slope is not reliable because
    #       vtsched may be updated instantaneously after this call.
    #    cur_scale - boolean array representing current scale
    #    cur_chord - boolean array representing current chord
    #    cur_bass - integer representing root of chord
    #
    display "play_a_measure", cur_beats_per_measure, cur_bps
    display "    ", cur_scale, cur_chord, cur_bass

    if cur_style == 'rock'
        #each elem represents the ratio of the Markov Chain transitioning to that
        #rhythm. Index 0 is whole note, 1 is half, 2 is quarter, etc the range is 
        #lower bound exclusive upper bound inclusive.
        ratio = [[-1, 0], [-1, 0], [-1, 0], [-1, 0], [-1, 0]]
        makeRatioRhythm(ratio)
        rhythmSeq = MarkovRhythm([], ratio, cur_beats_per_measure)

        #Same as ratio for rhythm, except index 0 is C, 1 is C#, etc last index 
        #is rest.
        ratio = [[-1, 0], [-1, 0], [-1, 0], [-1, 0], [-1, 0], [-1, 0], [-1, 0], 
                 [-1, 0], [-1, 0], [-1, 0], [-1, 0], [-1, 0], [-1, 0]]
        makeRatioPitch([], ratio)
        noteSeq = MarkovPitch([], ratio, rhythmSeq)
        midi_out.note(0, noteSeq[0][0] + 36, 100, noteSeq[0][1])
        curBeat = 4 / (2.0 ** real(noteSeq[0][1]))
        for i = 1 to len(noteSeq)
            dur = 4 / (2.0 ** real(noteSeq[i][1]))
            if noteSeq[i][0] == 12:
                vel = 0
            else
                vel = 100
            vtsched.cause(curBeat, midi_out, 'note', 0, noteSeq[i][0] + 36, vel,
                          dur)
            curBeat = curBeat + dur
