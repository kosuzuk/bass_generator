SERVICE = "bass"

require "playerbase"

density = 89
complexity = 99
range = 50
constantBass = false
rootDownbeat = true

def fader1_handler(time, address, types, float_param)
    display "fader1_handler", time, address, types, float_param
    vtsched.start_use()
    if float_param != 1: density = int(100 * float_param)
    display density
    vtsched.finish_use()

def fader2_handler(time, address, types, float_param)
    display "fader2_handler", time, address, types, float_param
    vtsched.start_use()
    if float_param != 1: complexity = int(100 * float_param)
    display complexity
    vtsched.finish_use()

def fader3_handler(time, address, types, float_param)
    display "fader3_handler", time, address, types, float_param
    vtsched.start_use()
    if float_param != 1: range = int(100 * float_param)
    display range
    vtsched.finish_use()

def toggle1_handler(time, address, types, int_param)
    display "toggle1_handler", time, address, types, int_param
    vtsched.start_use()
    constantBass = int_param
    display constantBass
    vtsched.finish_use()

def initializeServices()
    o2_osc_port_new(SERVICE, 8660, false)
    o2_method_new("/" + SERVICE + "/1/fader1", "f", 'fader1_handler', true)
    o2_method_new("/" + SERVICE + "/1/fader2", "f", 'fader2_handler', true)
    o2_method_new("/" + SERVICE + "/1/fader3", "f", 'fader3_handler', true)
    o2_method_new("/" + SERVICE + "/1/toggle1", "i", 'toggle1_handler', true)

initializeServices()

#(seq is the sequence of notes so far, ratio is array of ratios for transitioning 
# to states, density is a scale of [0, 100) to determine the amount of rest
# complexity is a scale of [0, 100) to 
# determine variation and complexity to rhythm)
def makeRatioRhythm(ratio)
    i = idiv(complexity, 20)
    if constantBass
        ratio[i] = [0, 100]
        return
    if i == 0
        ratio[idiv(99 - density, 20)] = [0, 100]
    elif i == 1
        if density < 75
            ratio[idiv(99 - density, 20)] = [0, 100]
        else
            ratio[1] = [0, 100]
    elif i == 4
        ratio[4] = [0, 67]
        ratio[3] = [67, 100]
    else
        ratio[i] = [0, 46]
        ratio[i + 1] = [46, 73]
        ratio[i - 1] = [73, 100]

def clearRatio(ratio)
    for i = 0 to 13
        ratio[i] = [-1, 0]

#(seq is the sequence of notes so far, ratio is array of ratios for transitioning
# to states, cur_scale, cur_chord, cur_bass, density is a scale of [0, 100) to 
# determine the amount of rest, complexity is a scale of [0, 100) to
# determine variation for eaxmple not starting on root, use of non-chord tones 
# and non-harmonic tones, wider jumps, range determines pitch range on a scale of [0, 100))
def makeRatioPitch(seq, ratio)
    clearRatio(ratio)
    if density == 0
        ratio[12] = [0, 100]
        return      
    if constantBass
        ratio[cur_bass] = [0, 100]
        return
    i = idiv(complexity, 20)
    if seq == []
        if rootDownbeat
            ratio[cur_bass] = [0, 100]
            return
        elif i < 2
            if density < 20
                restRatio = 99 - (density * 4)
            else
                restRatio = 0
        else
            restRatio = 99 - density
    else
        if i == 0
            restRatio = 99
        elif i == 1
            if density < 75
                restRatio = 99
            else
                restRatio = 0
        else
            restRatio = 99 - density
    ratio[12] = [100 - restRatio, 100]
    numNotesInChord = 0
    for i = 0 to 12
        if cur_chord[i]
            numNotesInChord = numNotesInChord + 1
    ratioInterval = 33
    if numNotesInChord == 4
        ratioInterval = ratioInterval - 8
    ratioInterval = int(ratioInterval * ((100 - restRatio) / 100))
    nthNoteInChord = 0
    total = restRatio + 1
    for i = 0 to 12
        if cur_chord[i]
            ratio[i][0] = nthNoteInChord * ratioInterval
            ratio[i][1] = ratio[i][0] + ratioInterval
            nthNoteInChord = nthNoteInChord + 1
            total = total + ratioInterval
            x = i
        else
            ratio[i] = [-1, 0]
    #add remaining ratios caused by decimal truncation as evenly as possible to
    #valid notes for output
    remainder = 100 - total
    i = 0
    while remainder != 0
        while ratio[i] == [-1, 0]
            i = (i + 1) % 12
        ratio[i][1] = ratio[i][1] + 1
        remainder = remainder - 1
        for j = i + 1 to 12
            if ratio[j] != [-1, 0]
                ratio[j] = [ratio[j][0] + 1, ratio[j][1] + 1]
        i = i + 1
    print "pitchRatio:", ratio

#(seq is the seq of rhythms so far, ratio is array of ratios for 
# transitioning to states, beatsLeft is num of beats left in the measure)
def MarkovRhythm(seq, ratio, beatsLeft)
    if beatsLeft < 0.2
        return seq
    x = int(random() * 100)
    for i = 0 to len(ratio)
        if ratio[i][0] <= x and ratio[i][1] > x and
           beatsLeft - 4 / (2.0 ** real(i)) > -0.2
            seq.append(i)
            beatsLeft = beatsLeft - 4 / (2.0 ** real(i))
    MarkovRhythm(seq, ratio, beatsLeft)

#(seq is the seq of notes so far, ratio is array of ratios for 
# transitioning to states, rhythmSeq is array of rhythm seq to match the pitch)
def MarkovPitch(seq, ratio, rhythmSeq)
    if len(seq) == len(rhythmSeq)
        return seq
    x = int(random() * 100)
    for i = 0 to len(ratio)
        if ratio[i][0] <= x and ratio[i][1] > x
            seq.append([i, rhythmSeq[len(seq)]])
    makeRatioPitch(seq, ratio)
    MarkovPitch(seq, ratio, rhythmSeq)

def play_a_measure()
    # compute a measure using these variables:
    #    cur_style - a symbol representing style to play (if
    #       this is not your style, do not play)
    #    cur_start_beat - what beat to start on if you are stopped
    #    cur_stop_beat - what beat to stop on if you have started (you can
    #       stop slightly late; generally you should not start any notes 
    #       at or after tm_stop_beat but you can play a short note on 
    #       tm_stop_beat if it is stylistically sensible.)
    #    cur_beats_per_measure - the current time signature as an integer
    #    cur_bps - current beats per second (the vtsched will implement this
    #       but reading the vtsched timemap slope is not reliable because
    #       vtsched may be updated instantaneously after this call.
    #    cur_scale - boolean array representing current scale
    #    cur_chord - boolean array representing current chord
    #    cur_bass - integer representing root of chord
    #
    display "play_a_measure", cur_beats_per_measure, cur_bps
    display "    ", cur_scale, cur_chord, cur_bass

    if cur_style == 'rock'
        #each elem represents the ratio of the Markov Chain transitioning to that
        #rhythm. Index 0 is whole note, 1 is half, 2 is quarter, etc the range is 
        #lower bound exclusive upper bound inclusive.
        new = []
        ratio = [[-1, 0], [-1, 0], [-1, 0], [-1, 0], [-1, 0]]
        beatsLeft = cur_beats_per_measure
        if complexity > 59 and rootDownbeat and constantBass == false
            new.append(2)
            beatsLeft = beatsLeft - 1
        makeRatioRhythm(ratio)
        rhythmSeq = MarkovRhythm(new, ratio, beatsLeft)

        #Same as ratio for rhythm, except index 0 is C, 1 is C#, etc last index 
        #is rest.
        ratio = [[-1, 0], [-1, 0], [-1, 0], [-1, 0], [-1, 0], [-1, 0], [-1, 0], 
                 [-1, 0], [-1, 0], [-1, 0], [-1, 0], [-1, 0], [-1, 0]]
        makeRatioPitch([], ratio)
        noteSeq = MarkovPitch([], ratio, rhythmSeq)
        curBeat = 4 / (2.0 ** real(noteSeq[0][1]))
        if noteSeq[0][0] == 12
            vel = 0
        else
            vel = 100
        midi_out.note(0, noteSeq[0][0] + 36, vel, curBeat - .01)
        print "noteSeq:", noteSeq
        for i = 1 to len(noteSeq)
            dur = 4 / (2.0 ** real(noteSeq[i][1]))
            if noteSeq[i][0] == 12
                vel = 0
            else
                vel = 100
            vtsched.cause(curBeat, midi_out, 'note', 0, noteSeq[i][0] + 36, vel,
                          dur - .01)
            curBeat = curBeat + dur
