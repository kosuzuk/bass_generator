SERVICE = "BassAndEffects"

require "playerbase"

density = 50
complexity = 80
range = 49
constantBass = false

#(seq is the sequence of notes so far, ratio is array of ratios for transitioning 
# to states, density is a scale of [0, 100) to determine the amount of rest
# complexity is a scale of [0, 100) to 
# determine variation and complexity to rhythm)
def makeRatioRhythm(seq, ratio, density, complexity):
    if seq == []
        i = idiv(complexity, 20)
        if i == 0
            ratio[idiv(99 - density, 20)] = [0, 100]
        elif i == 1
            ratio[1] = [0, 49]
            ratio[2] = [49, 100]
        elif i == 4
            ratio[4] = [0, 67]
            ratio[3] = [67, 100]
        else
            ratio[i] = [0, 46]
            ratio[i + 1] = [46, 73]
            ratio[i - 1] = [73, 100]

#(seq is th e sequence of notes so far, ratio is array of ratios for transitioning
# to states, cur_scale, cur_chord, cur_bass, density is a scale of [0, 100) to 
# determine the amount of rest, complexity is a scale of [0, 100) to
# determine variation for eaxmple not starting on root, use of non-chord tones 
# and non-harmonic tones, wider jumps, range determines pitch range on a scale of [0, 100))
def makeRatioPitch(seq, ratio, scale, chord, root, density, complexity, range):
    numNotesInChord = 0
    for i = 0 to 12
        if cur_chord[i]
            numNotesInChord = numNotesInChord + 1
    ratioInterval = 33
    if numNotesInChord == 4
        ratioInterval = ratioInterval - 8
    nthNoteInChord = 0
    for i = 0 to 12
        if cur_chord[i]
            ratio[i][0] = ratio[i][0] + nthNoteInChord * ratioInterval + 1
            ratio[i][1] = ratio[i][0] + ratioInterval
            if numNotesInChord == 3 and nthNoteInChord == 2
                ratio[i][1] = ratio[i][1] + 1
            nthNoteInChord = nthNoteInChord + 1

#(seq is array of states visited so far, ratio is array of ratios for 
# transitioning to states, beatsLeft is num of beats left in the measure)
def MarkovRhythm(seq, ratio, beatsLeft):
    if beatsLeft < 0.2
        return seq
    x = int(random() * 100)
    for i = 0 to len(ratio)
        if ratio[i][0] <= x and ratio[i][1] > x
            seq.append(i)
    MarkovRhythm(seq, ratio, beatsLeft - 4 / (2.0 ** real(seq[len(seq) - 1])))

#(seq is array of states visited so far, ratio is array of ratios for 
# transitioning to states, rhythmSeq is array of rhythm seq to match the pitch)
def MarkovPitch(seq, ratio, rhythmSeq):
    if len(seq) == len(rhythmSeq)
        return seq
    x = int(random() * 100)
    for i = 0 to len(ratio)
        if ratio[i][0] <= x and ratio[i][1] > x
            seq.append([i, rhythmSeq[len(seq)]])
    #, scale, chord, root, complexity, range
    MarkovPitch(seq, ratio, rhythmSeq)

def play_a_measure()
    # compute a measure using these variables:
    #    cur_style - a symbol representing style to play (if
    #       this is not your style, do not play)
    #    cur_start_beat - what beat to start on if you are stopped
    #    cur_stop_beat - what beat to stop on if you have started (you can
    #       stop slightly late; generally you should not start any notes 
    #       at or after tm_stop_beat but you can play a short note on 
    #       tm_stop_beat if it is stylistically sensible.)
    #    cur_beats_per_measure - the current time signature as an integer
    #    cur_bps - current beats per second (the vtsched will implement this
    #       but reading the vtsched timemap slope is not reliable because
    #       vtsched may be updated instantaneously after this call.
    #    cur_scale - boolean array representing current scale
    #    cur_chord - boolean array representing current chord
    #    cur_bass - integer representing root of chord
    #
    display "play_a_measure", cur_beats_per_measure, cur_bps
    display "    ", cur_scale, cur_chord, cur_bass

    if cur_style == 'rock'
        #each elem represents the ratio of the Markov Chain transitioning to that
        #rhythm. Index 0 is whole note, 1 is half, 2 is quarter, etc the range is 
        #lower bound exclusive upper bound inclusive.
        ratio = [[-1, 0], [-1, 0], [-1, 0], [-1, 0], [-1, 0]]
        makeRatioRhythm([], ratio, density, complexity)
        rhythmSeq = MarkovRhythm([], ratio, cur_beats_per_measure)

        #Same as ratio for rhythm, except index 0 is C, 1 is C#, etc last index 
        #is rest.
        ratio = [[-1, 0], [-1, 0], [-1, 0], [-1, 0], [-1, 0], [-1, 0], [-1, 0], 
                 [-1, 0], [-1, 0], [-1, 0], [-1, 0], [-1, 0], [-1, 0]]
        makeRatioPitch([], ratio, cur_scale, cur_chord, cur_bass, density, complexity, range)
        noteSeq = MarkovPitch([], ratio, rhythmSeq)
        print noteSeq
        midi_out.note(0, noteSeq[0][0] + 36, 100, noteSeq[0][1])
        curBeat = 4 / (2.0 ** real(noteSeq[0][1]))
        for i = 1 to len(noteSeq)
            vtsched.cause(curBeat, midi_out, 'note', 0, noteSeq[i][0] + 36, 100,
                          noteSeq[i][1])
            curBeat = curBeat + (4 / (2.0 ** real(noteSeq[i][1])))
