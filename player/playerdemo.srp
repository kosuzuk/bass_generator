SERVICE = "BassAndEffects"

require "playerbase"

def MarkovRhythm(seq, ratio, beatsLeft, density, complexity):
    if beatsLeft == 0
        return seq
    x = int(random() * 100)
    for i = 0 to len(ratio)
        if ratio[i][0] <= x and ratio[i][1] > x
            seq.append(i)
    MarkovRhythm(seq, ratio, beatsLeft - 4 / (2.0 ** real(i)), 
                 density, complexity)

def MarkovPitch(seq, ratio, rhythmSeq, scale, chord, root, complexity, range):
    if len(seq) == len(rhythmSeq)
        return seq
    x = int(random() * 100)
    for i = 0 to len(ratio)
        if ratio[i][0] <= x and ratio[i][1] > x
            seq.append([i, rhythmSeq[len(seq)]])
    MarkovPitch(seq, ratio, rhythmSeq, scale, chord, root, complexity, range)

def play_a_measure()
    # compute a measure using these variables:
    #    cur_style - a symbol representing style to play (if
    #       this is not your style, do not play)
    #    cur_start_beat - what beat to start on if you are stopped
    #    cur_stop_beat - what beat to stop on if you have started (you can
    #       stop slightly late; generally you should not start any notes 
    #       at or after tm_stop_beat but you can play a short note on 
    #       tm_stop_beat if it is stylistically sensible.)
    #    cur_beats_per_measure - the current time signature as an integer
    #    cur_bps - current beats per second (the vtsched will implement this
    #       but reading the vtsched timemap slope is not reliable because
    #       vtsched may be updated instantaneously after this call.
    #    cur_scale - boolean array representing current scale
    #    cur_chord - boolean array representing current chord
    #    cur_bass - integer representing root of chord
    #
    display "play_a_measure", cur_beats_per_measure, cur_bps
    display "    ", cur_scale, cur_chord, cur_bass

    if cur_style == 'rock'
        #midi_out.note(chan, key, vel, dur)
        #vtsched.cause(beat, midi_out, 'note', chan, key, vel, dur)

        #each elem represents the prob of the Markov Chain transitioning to that
        #rhythm. Index 0 is whole note, 1 is half, 2 is quarter, etc the range 
        #is lower bound exclusive upper bound inclusive.
        rhythmProb = [[-1, 0], [-1, 0], [0, 100], [-1, 0], [-1, 0]]

        rhythmSeq = MarkovRhythm([], rhythmProb, cur_beats_per_measure, 0, 0)
        
        #Same as rhythmProb, except index 0 is C, 1 is C#, etc last index is rest.
        pitchProb = [[-1, 0], [-1, 0], [-1, 0], [-1, 0], [-1, 0], [-1, 0], 
                     [-1, 0], [-1, 0], [-1, 0], [-1, 0], [-1, 0], [-1, 0], [-1, 0]]

        numNotesInChord = 0
        for i = 0 to 12
            if cur_chord[i]
                numNotesInChord = numNotesInChord + 1
        ratioInterval = 33
        if numNotesInChord == 4
            ratioInterval = ratioInterval - 8
        nthNoteInChord = 0
        for i = 0 to 12
            if cur_chord[i]
                pitchProb[i][0] = pitchProb[i][0] + nthNoteInChord * ratioInterval + 1
                pitchProb[i][1] = pitchProb[i][0] + ratioInterval
                if numNotesInChord == 3 and nthNoteInChord == 2
                    pitchProb[i][1] = pitchProb[i][1] + 1
                nthNoteInChord = nthNoteInChord + 1
        noteSeq = MarkovPitch([], pitchProb, rhythmSeq, cur_scale,
                              cur_chord, cur_bass, 0, 0)

        midi_out.note(0, noteSeq[0][0] + 36, 100, noteSeq[0][1])
        curBeat = 4 / (2.0 ** real(noteSeq[0][1]))
        for i = 1 to len(noteSeq)
            vtsched.cause(curBeat, midi_out, 'note', 0, noteSeq[i][0] + 36, 100,
                          noteSeq[i][1])
            curBeat = curBeat + (4 / (2.0 ** real(noteSeq[i][1])))
